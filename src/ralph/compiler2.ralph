(define-module ralph/compiler2
  import: (ralph/core ralph/format ralph/regexp ralph/reader)
  export: (<environment> macroexpand-1
                         macroexpand
                         macroexpand-all
                         alpha-convert
                         beta-reduce
                         reset-symbol-counter!
                         atomic?
                         normalize-term))

;; - everything is an expression, ANF transformation produces statements
;; - instead of trying to use JS statements (while) as expression,
;;   by wrapping them in lambdas, allways generate statements (while, but also if, etc.)
;;   (e.g. instead of "return x ? (x = 3, 1) : 2"
;;         => "var t1; if (x) { x = 3; t1 = 1 } else { t1 = 2 }; return t1")
;; - closures are expensive, try to only generate them when necessary

;; - TODO: bind and alpha-conversion allows block scope -> don't transform bind to lambda
;; - TODO: transform bind to js:var in last pass, flatten variable to nearest lambda
;; - TODO: bind had return, as it is an expression; only leave for last when flattening
;; - TODO: lift symbols (keywords), use same binding
;; - TODO: remove top-level expressions without side-effects (constants)

;; Languages
;;
;; - ANF algorithm assumes unique naming of variables:
;;   "We assume the front-end uniquely renames all variables [...]"
;; => alpha-conversion before ANF
;;
;; L1:
;; <prog> ::= <dec> ...
;; <dec> ::= (define <var> <exp>)
;;        |  (define-function <var> (<name> ...) <exp> ...)
;;        |  (define-function (setter <var>) (<name> ...) <exp> ...)
;;        |  (define-generic <var> (<name> ...))
;;        |  (define-method <var> (<name> ...) <exp> ...)
;;        |  (define-method (setter <var>) (<name> ...) <exp> ...)
;;        |  <exp>
;;
;; <exp> ::= (bind ((<var> <exp>) ...) <exp> ...)
;;        |  (begin <exp> ...)
;;        |  (if <exp> <exp> <exp>)
;;        |  (when <exp> <exp> ...)
;;        |  (unless <exp> <exp> ...)
;;        |  (set! <var> <exp> ...)
;;        |  (set! <exp> <exp> ...)
;;        |  (method (<name> ...) <exp> ...)
;;        |  (and <exp> ...)
;;        |  (or <exp> ...)
;;        |  <number>
;;        |  <boolean>
;;        |  <string>
;;        |  <var>
;;

;; L2: expanded top-level defines
;; <prog> ::= <dec> ...
;; <dec> ::= (define <var> <L1.exp>)
;;        |  <L1.exp>
;;
;; L3: macroexpanded
;; L4: alpha-converted
;; L5: in ANF
;; L6: beta-reduced
;;
;; JS back-end transformations:
;;   %make-function <ralph-name-string> => %make-function <js-name-string>
;;   ...

;;;; utilities

(define-function expression? (form)
  (and (instance? form <array>)
       (not (empty? form))
       (instance? (first form) <symbol>)))

(define-function setter-symbol (function-symbol)
  (symbol (concatenate "%%set-" (symbol-name function-symbol))))

(define-function setter-name? (name)
  (and (instance? name <array>)
       (== (size name) 2)
       (every? (rcurry instance? <symbol>))
       (== (symbol-name (first name)) "setter")))

(define *symbol-count* 0)

(define-function reset-symbol-counter! ()
  (set! *symbol-count* 0))

(define-function generate-symbol ()
  (symbol (concatenate "%_" (as-string (inc! *symbol-count*)))))

;;;; special forms

(define *special-forms*
  (make-object))

(define-function special-form-definition (form env)
  (get *special-forms* (symbol-name (first form))))

(define-macro define-special-form (name #rest definition)
  `(set! (get *special-forms* ,(symbol-name name))
         ,(concatenate `(method)
                       definition)))

;; function with fixed argument list
(define-special-form
  %method (env arguments #rest body)
  (concatenate `(%method ,arguments)
               (map (rcurry macroexpand-all env) body)))

(define-special-form
  %set (env name value)
  `(%set ,name ,(macroexpand-all value env)))


;;;; macros

(define *default-macros*
  (make-object))

(define-macro define-default-macro (name #rest definition)
  `(set! (get *default-macros* ,(symbol-name name))
         ,(concatenate `(method)
                       definition)))

(define-default-macro begin (_ #rest expressions)
  (if (> (size expressions) 1)
      (concatenate `(%begin)
                   expressions)
      (first expressions)))

;; TODO: only transform to single bind, not lambda!
(define-default-macro bind (_ bindings #rest body)
  (if (empty? bindings)
      (concatenate `(begin) body)
      (bind ((binding (first bindings)))
        (destructuring-bind (var value) binding
          `((%method (,var)
              ,(concatenate `(bind ,(rest bindings))
                            body))
            ,value)))))

(define-default-macro cond (_ #rest cases)
  (unless (empty? cases)
    (destructuring-bind (test #rest then) (first cases)
      (bind ((then (concatenate `(begin) then)))
        (if (== test else:)
            then
            `(if ,test
                 ,then
                 ,(concatenate `(cond)
                               (rest cases))))))))

(define-default-macro when (_ condition #rest body)
  `(if ,condition
       ,(concatenate `(begin)
                     body)
       #f))

(define-default-macro set! (_ place #rest rest)
  (if (instance? place <array>)
      (concatenate `(,(setter-symbol (first place)))
                   (rest place)
                   rest)
      `(%set ,place ,(first rest))))

;;;; macro expansion

(define-class <environment> (<object>)
  (macros *default-macros*))

(define-function macro-definition (form env)
  (get env "macros" (symbol-name (first form))))

(define-function macroexpand-1 (form env)
  (if-bind (macro (and (expression? form)
                       (macro-definition form env)))
    (apply macro env (rest form))
    form))

(define-function macroexpand (form env)
  (bind ((expanded (macroexpand-1 form env)))
    (if (== expanded form)
        form
        (macroexpand expanded env))))

(define-function macroexpand-all (form env)
  (select form instance?
    ((<array>)
     (if (macro-definition form env)
         (macroexpand-all (macroexpand form env) env)
         (if-bind (expander (special-form-definition form env))
           (apply expander env (rest form))
           (map (rcurry macroexpand-all env)
                form))))
    ;; TODO: symbol macro ((<symbol>) )
    (else: form)))

;;;; alpha conversion

(define-function rename-variables (variables env)
  (bind ((env (wrap-object env)))
    [(map (method (variable)
            (set! (get env (symbol-name variable))
                  (generate-symbol)))
          variables)
     env]))

(define-function find-variable (variable env)
  ;; TODO: use find-property, signal error if not found
  (js:get-property env (symbol-name variable)))

(define-function alpha-convert (form env)
  (select form instance?
    ((<array>)
     (if (== (symbol-name (first form)) "%method")
         (destructuring-bind (_ arguments #rest body) form
           (destructuring-bind (new-arguments env)
               (rename-variables arguments env)
             (concatenate `(%method ,new-arguments)
                          (map (rcurry alpha-convert env)
                               body))))
         (map (rcurry alpha-convert env)
              form env)))
    ((<symbol>)
     (or (find-variable form env)
         form))
    (else: form)))

;;;; beta reduction

;; ((L (x y) (+ x y)) a (+ a 1))
;; => ((L (y) (+ a y)) (+ a 1))

(define-function substitute-variables (variables new-variables env)
  (bind ((env (wrap-object env)))
    (for-each ((variable variables)
               (new-variable new-variables))
              ()
      (set! (get env (symbol-name variable))
            new-variable))
    env))


;; TODO: eliminate
;; ((L () X)) => X
;; (begin 1) => 1

(define-function beta-reduce (form env)
  (select form instance?
    ((<array>)
     ;; TODO: bind
     (if (and (instance? (first form) <array>)
              (== (symbol-name (first (first form))) "%method"))
         (destructuring-bind ((_ arguments #rest body) #rest values)
             form
           ;; TODO: maybe also support constant values (numbers, etc.)
           (bind ((variables [])
                  (new-variables [])
                  (new-arguments [])
                  (new-values []))
             (for-each ((argument arguments)
                        (value values))
                 ()
               (if (atomic? value)
                   (begin
                    (push-last variables argument)
                    (push-last new-variables value))
                   (begin
                    (push-last new-arguments argument)
                    (push-last new-values value))))
             (bind ((env (substitute-variables variables new-variables env))
                    (body (map (rcurry beta-reduce env)
                               body)))
               (concatenate `(,(concatenate `(%method ,new-arguments)
                                            body))
                            new-values))))
         (map (rcurry beta-reduce env)
              form env)))
    ((<symbol>)
     (or (find-variable form env)
         form))
    (else: form)))


;; ANF
;; * see:
;;   - "The Essence of Compiling with Continuations"
;;     Flanagan, Sabry, Duba, Felleisen
;;   - "A-Normalization: Why and How"
;;     Matt Might (http://matt.might.net/articles/a-normalization/)
;; * modified to support:
;;   - sequence of expressions in method, bind and begin
;;   - expression names and additional arguments for set!
;;
;;   [`(λ ,params . ,body)
;;     (k `(λ ,params ,(normalize-term `(begin . ,body))))]
;;
;;   [`(let () . ,e*)
;;     (normalize `(begin . ,e*) k)]
;;
;;   [`(let ([,x ,exp1] . ,clause) . ,e*)
;;     (normalize exp1 (λ (aexp1)
;;      `(let ([,x ,aexp1])
;;        ,(normalize `(let (,@clause) . ,e*) k))))]
;;
;;   [`(begin ,exp)
;;    (normalize exp k)]
;;
;;   [`(begin ,exp . ,e*)
;;     (normalize exp (λ (aexp)
;;      `(begin ,aexp
;;         ,(normalize `(begin ,@e*) k))))]
;;
;;   [`(set! ,v ,exp . ,e*)
;;    (normalize-name exp (λ (t)
;;      (normalize-name* e* (λ (t*)
;;          (k `(set! ,v ,t . ,t*))))))]


(define-function atomic? (expression)
  (any? (curry instance? expression)
        [<number> <boolean> <string> <symbol>
                  ;; TODO: aren't keywords symbols?
                  <keyword>]))

(define-function normalize-term (expression)
  (normalize expression identity))

(define-function normalize (exp k)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("method")
         (destructuring-bind (_ (#rest arguments) #rest body) exp
           (k `(method ,arguments
                 ,(normalize-term
                   (concatenate `(begin) body))))))
        (("begin")
         (destructuring-bind (_ exp1 #rest e*) exp
           (if (empty? e*)
               (normalize exp1 k)
               (normalize
                exp1 (method (aexp1)
                       `(begin
                         ,aexp1
                         ,(normalize (concatenate
                                      `(begin)
                                      e*)
                                     k)))))))
        (("bind")
         (destructuring-bind (_ (#rest clauses) #rest body) exp
           (if (empty? clauses)
               (normalize (concatenate `(begin) body) k)
               (destructuring-bind (var exp1)
                   (first clauses)
                 (normalize
                  exp1 (method (aexp1)
                         `(bind ((,var ,aexp1))
                            ,(normalize (concatenate
                                         `(bind ,(rest clauses))
                                         body)
                                        k))))))))
        (("if")
         (destructuring-bind (_ exp1 exp2 exp3) exp
           (normalize-name
            exp1 (method (aexp1)
                   (k `(if ,aexp1
                           ,(normalize-term exp2)
                           ,(normalize-term exp3)))))))
        (("set!")
         (destructuring-bind (_ var exp1 #rest e*) exp
           (normalize-name
            exp1 (method (aexp1)
                   (normalize-name*
                    e* (method (t*)
                         (k (concatenate `(set! ,var ,aexp1)
                                         t*))))))))
        (else:
         (destructuring-bind (f #rest e*) exp
           (normalize-name
            f (method (t)
                (normalize-name*
                 e* (method (t*)
                      (k (concatenate [t] t*)))))))))
      (k exp)))

(define-function normalize-name (exp k)
  (normalize exp
             (method (aexp)
               (if (atomic? aexp)
                   (k aexp)
                   (bind ((t (generate-symbol)))
                     `(bind ((,t ,aexp))
                        ,(k t)))))))

(define-function normalize-name* (exp* k)
  (if (empty? exp*)
      (k [])
      (normalize-name
       (first exp*) (method (t)
                      (normalize-name*
                       (rest exp*) (method (t*)
                                     (k (concatenate [t] t*))))))))


;;;; top-level expansion

(define-function function-definer (macro-name definer-name type?)
  (method (_ function-name arguments #rest body)
    (destructuring-bind (setter? name)
        (if (setter-name? function-name)
            [#t (setter-symbol (second function-name))]
            [#f function-name])
      (when (not (or (instance? name <symbol>)
                     setter?))
        (signal (make <error> message:
                      (concatenate macro-name ": name not <var> or (setter <var>)"))))
      `(define ,name
         ,(concatenate
           `(,(S definer-name)
             ,(symbol-name name)
             ,(concatenate `(method ,arguments)
                           body)
             setter?
             ,(when (and type?
                           (not (empty? arguments)))
                (bind ((head (first arguments)))
                  (if (and (instance? head <array>)
                           (> (size head) 1))
                      (second head)
                      (S "<object>"))))))))))

(define *top-level-macros*
  (make-object
   "define-generic"
   (method (_ name arguments)
     `(define ,name
        (%make-generic ,(symbol-name ,name))))))

(for-each ((arguments [["define-function" "%make-function" #f]
                       ["define-method" "%make-method" #t]]))
          ()
  (set! (get *top-level-macros* (first arguments))
        (apply function-definer arguments)))

(set! (get *top-level-macros* )
      (apply function-definer arguments)))

(define-function macroexpand-program (declarations)
  (map (rcurry macroexpand-1 *top-level-macros*)
       declarations))



