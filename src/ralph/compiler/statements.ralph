(define-module ralph/compiler/statements
  import: (ralph/compiler/utilities)
  export: (transform-statements!))


;; "sink"/wrap return value with expression
;; e.g. to assign or explicitly return

(define-function wrap-value! (exp wrapper)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%quote") 
         exp)
        (("%begin" "%bind")
         ;; wrap body
         (set! (last exp)
               (wrap-value! (last exp) wrapper))
         exp)
        (("%if")
         ;; wrap consequent and alternate
         (set! (third exp)
               (wrap-value! (third exp) wrapper))
         (set! (last exp)
               (wrap-value! (last exp) wrapper))
         exp)
        (("%while")
         `(%begin
           ,exp
           ,(wrap-value! #f wrapper)))
        (("%try")
         (set! (second exp)
               (wrap-value! (second exp) wrapper))
         (set! (last exp)
               (wrap-value! (last exp) wrapper))
         exp)
        (else:
         (concatenate wrapper [exp])))
      (concatenate wrapper [exp])))


(define-function add-explicit-return (exp)
  (wrap-value! exp `(%native-call "return")))

;; after ANF: if value of binding is control-flow (%if, %while, etc.):
;; turn into statement form, then "sink" assignment

(define-function statement? (exp)
  (and (instance? exp <array>)
       (not (empty? exp))
       (member? (first exp)
                `(%if %while %begin %bind %try))))

(define-function add-explicit-true (exp)
  (if (instance? exp <boolean>)
      (true? exp)
      `((%native "$T") ,exp)))


(define-function wrap-export (identifier exp env)
  (bind ((definition-name (symbol-name identifier))
         (exported? (member? definition-name
                             (get env "module" "exports"))))
    ;; defined and exported?
    (if exported?
        `(%begin
          ,exp
          (%set (%get-property (%native "exports")
                               ,definition-name)
                ,identifier))
        exp)))

(define-function transform-statements! (exp env)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%quote")
         exp)
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (if (statement? value)
               `(%bind (,var #f)
                  (%begin
                   ,(wrap-value!
                     (transform-statements! value env)
                     `(%set ,var))
                   ,(transform-statements! body env)))
               `(%bind (,var
                        ,(transform-statements! value env))
                  ,(transform-statements! body env)))))
        (("%method")
         (set! (last exp)
               (add-explicit-return
                (transform-statements! (last exp)
                                      env)))
         exp)
        (("%set")
         (destructuring-bind (_ place value) exp
           (wrap-export place
                        `(%set ,place
                               ,(transform-statements!
                                 value env))
                        env)))
        (("%define")
         (transform-statements!
          `(%var ,(second exp)
                 ,(third exp))
          env))
        (("%if")
         (destructuring-bind (_ test then else) exp
           `(%if
             ;; TODO: only if not boolean
             ,(add-explicit-true
               ;; might contain nested method
               (transform-statements! test env))
             ,(transform-statements! then env)
             ,(transform-statements! else env))))
        (("%begin")
         (destructuring-bind (_ #rest exps) exp
           `(%begin
             ,@(map (rcurry transform-statements! env)
                    exps))))
        (("%while")
         (set! (second exp)
               ;; TODO: only if not boolean
               (add-explicit-true
                (transform-statements! (second exp) env)))
         (set! (third exp)
               (transform-statements! (third exp) env))
         exp)
        (("%try")
         (set! (second exp)
               (transform-statements! (second exp) exp))
         (set! (last exp)
               (transform-statements! (last exp) env))
         exp)
        (("%var")
         (destructuring-bind (_ identifier value) exp
           (wrap-export identifier
                        `(%var ,identifier
                               ,(transform-statements!
                                 value env))
                        env)))
        (else:
         (map (rcurry transform-statements! env) exp)))
      exp))

