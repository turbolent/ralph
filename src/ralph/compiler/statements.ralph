(define-module ralph/compiler/statements
  import: (ralph/compiler/utilities
           ralph/compiler/environment
           ralph/compiler/transformer
           ralph/format)
  export: (transform-statements!))


;; "sink"/wrap return value with expression
;; e.g. to assign or explicitly return

(define-function wrap-value! (exp wrapper)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%quote")
         exp)
        (("%begin" "%bind")
         ;; wrap body
         (set! (last exp)
               (wrap-value! (last exp) wrapper))
         exp)
        (("%if")
         ;; wrap consequent and alternate
         (set! (third exp)
               (wrap-value! (third exp) wrapper))
         (set! (last exp)
               (wrap-value! (last exp) wrapper))
         exp)
        (("%while")
         `(%begin
           ,exp
           ,(wrap-value! #f wrapper)))
        (("%try")
         (set! (second exp)
               (wrap-value! (second exp) wrapper))
         (set! (last exp)
               (wrap-value! (last exp) wrapper))
         exp)
        (else:
         (concatenate wrapper [exp])))
      (concatenate wrapper [exp])))


(define-function wrap-return (exp)
  (wrap-value! exp `(%native-call "return")))

;; after ANF: if value of binding is control-flow (%if, %while, etc.):
;; turn into statement form, then "sink" assignment

(define $statement-symbols `(%if %while %begin %bind %try))

(define-function generates-statement? (exp)
  (and (instance? exp <array>)
       (not (empty? exp))
       (member? (first exp)
                $statement-symbols)))

(define-function wrap-true (exp)
  (if (instance? exp <boolean>)
      (true? exp)
      `((%native "$T") ,exp)))


(define-function wrap-export (identifier exp env)
  (bind ((definition-name (symbol-name identifier))
         (exported? (member? definition-name
                             (get env "module" "exports"))))
    ;; defined and exported?
    (if exported?
        `(%begin
          ,exp
          (%set (%get-property (%native "exports")
                               ,definition-name)
                ,identifier))
        exp)))



(define *transformers*
  (make-plain-object))

(define-function transform-statements! (exp env)
  (select exp instance?
    ((<array>)
     (bind ((name (symbol-name (first exp))))
       (select name ==
         (("%set")
          (destructuring-bind (_ place value) exp
            (wrap-export place
                         `(%set ,place
                                ,(transform-statements!
                                  value env))
                         env)))
         ;; TODO: bind-globally!
         (("%var" "%define")
          (destructuring-bind (_ identifier value) exp
            (wrap-export identifier
                         `(%var ,identifier
                                ,(transform-statements!
                                  value env))
                         env)))
         (else:
          (if-bind (transformer (get *transformers* name))
            (apply transformer env (rest exp))
            (map (rcurry transform-statements! env) exp))))))
    ((<symbol>)
      (when (and (. (symbol-name exp) (match "_\\d+$"))
                 (not (locally-bound? exp env)))
        (format-out "LOCAL SYMBOL NOT LOCALLY BOUND: %=\n" exp))
      exp)
    (else: exp)))

(set! (get *transformers* "%quote")
      (make-quote-transformer `%quote))

(set! (get *transformers* "%bind")
      (make-bind-transformer transform-statements!
                             (method (identifier value* body*)
                               (if (generates-statement? value*)
                                   `(%begin
                                      (%var ,identifier #f)
                                      ,(wrap-value! value*
                                                    `(%set ,identifier))
                                      ,body*)
                                   `(%begin
                                      (%var ,identifier ,value*)
                                      ,body*)))))

(set! (get *transformers* "%method")
      (make-method-transformer transform-statements!
                               (method (name parameters form*)
                                 `(%method ,name ,parameters
                                    ,(wrap-return form*)))))

(set! (get *transformers* "%if")
      (make-rest-transformer
        transform-statements!
        count: 3
        k: (method (predicate* consequent* alternate*)
             `(%if ,(wrap-true predicate*)
                   ,consequent*
                   ,alternate*))))

(set! (get *transformers* "%while")
      (make-rest-transformer
        transform-statements!
        count: 2
        k: (method (predicate* form*)
             `(%while ,(wrap-true predicate*)
                ,form*))))

(set! (get *transformers* "%try")
      (make-try-transformer transform-statements!))

(set! (get *transformers* "%object")
      (make-object-transformer transform-statements!))

(for-each ((symbol `(%native-call %infix)))
          ()
  (set! (get *transformers* (symbol-name symbol))
        (make-operator-transformer symbol transform-statements!)))

(for-each ((symbol `(%begin %native %array %get-property)))
          ()
  (set! (get *transformers* (symbol-name symbol))
        (make-rest-transformer transform-statements!
                               symbol: symbol)))
