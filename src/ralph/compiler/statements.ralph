(define-module ralph/compiler/statements
  import: (ralph/compiler/utilities
           ralph/compiler/environment
           ralph/format)
  export: (transform-statements!))


;; "sink"/wrap return value with expression
;; e.g. to assign or explicitly return

(define-function wrap-value! (exp wrapper)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%quote")
         exp)
        (("%begin" "%bind")
         ;; wrap body
         (set! (last exp)
               (wrap-value! (last exp) wrapper))
         exp)
        (("%if")
         ;; wrap consequent and alternate
         (set! (third exp)
               (wrap-value! (third exp) wrapper))
         (set! (last exp)
               (wrap-value! (last exp) wrapper))
         exp)
        (("%while")
         `(%begin
           ,exp
           ,(wrap-value! #f wrapper)))
        (("%try")
         (set! (second exp)
               (wrap-value! (second exp) wrapper))
         (set! (last exp)
               (wrap-value! (last exp) wrapper))
         exp)
        (else:
         (concatenate wrapper [exp])))
      (concatenate wrapper [exp])))


(define-function add-explicit-return (exp)
  (wrap-value! exp `(%native-call "return")))

;; after ANF: if value of binding is control-flow (%if, %while, etc.):
;; turn into statement form, then "sink" assignment

(define-function statement? (exp)
  (and (instance? exp <array>)
       (not (empty? exp))
       (member? (first exp)
                `(%if %while %begin %bind %try))))

(define-function add-explicit-true (exp)
  (if (instance? exp <boolean>)
      (true? exp)
      `((%native "$T") ,exp)))


(define-function wrap-export (identifier exp env)
  (bind ((definition-name (symbol-name identifier))
         (exported? (member? definition-name
                             (get env "module" "exports"))))
    ;; defined and exported?
    (if exported?
        `(%begin
          ,exp
          (%set (%get-property (%native "exports")
                               ,definition-name)
                ,identifier))
        exp)))

;; TODO: very similar to internal-special-forms, refactor:
;;       pass transformation function and callback
(define-function transform-statements! (exp env)
  (select exp instance?
    ((<array>)
     (select (symbol-name (first exp)) ==
       (("%quote" "%native" "%native-call")
        exp)
       (("%infix" "%object" "%array" "%get-property")
        `(,(first exp)
          ,@(map (rcurry transform-statements! env)
                 (rest exp))))
       (("%bind")
        (destructuring-bind (_ (identifier value) body) exp
          (bind ((value* (transform-statements! value env)))
            (bind-locally! identifier env)
            (bind ((body* (transform-statements! body env)))
              (unbind-locally! identifier env)
              (if (statement? value)
                  `(%begin
                     (%var ,identifier #f)
                     ,(wrap-value! value* `(%set ,identifier))
                     ,body*)
                  `(%begin
                     (%var ,identifier ,value*)
                     ,body*))))))
       (("%method")
        (destructuring-bind (_ name parameters form) exp
          (bind ((identifiers (cons name parameters)))
            ;; bind identifiers
            (do (rcurry bind-locally! env)
                identifiers)
            ;; expand form
            (bind ((form* (transform-statements! form env)))
              ;; unbind identifiers
              (do (rcurry unbind-locally! env)
                  identifiers)
              ;; result
              `(%method ,name ,parameters
                        ,(add-explicit-return form*))))))
       (("%set")
        (destructuring-bind (_ place value) exp
          (wrap-export place
                       `(%set ,place
                              ,(transform-statements!
                                value env))
                       env)))
       (("%define")
        (destructuring-bind (_ identifier value) exp
          (bind ((exp* (transform-statements!
                         `(%var ,identifier ,value)
                         env)))
            (bind-globally! identifier env)
            exp*)))
       (("%if")
        (destructuring-bind (_ test then else) exp
          `(%if
            ;; TODO: only if not boolean
            ,(add-explicit-true
              ;; might contain nested method
              (transform-statements! test env))
            ,(transform-statements! then env)
            ,(transform-statements! else env))))
       (("%begin")
        (destructuring-bind (_ #rest exps) exp
          `(%begin
            ,@(map (rcurry transform-statements! env)
                   exps))))
       (("%while")
        (set! (second exp)
              ;; TODO: only if not boolean
              (add-explicit-true
               (transform-statements! (second exp) env)))
        (set! (third exp)
              (transform-statements! (third exp) env))
        exp)
       ;; TODO: bind-locally!
       (("%try")
        (set! (second exp)
              (transform-statements! (second exp) exp))
        (set! (last exp)
              (transform-statements! (last exp) env))
        exp)
       ;; TODO: bind-globally!
       (("%var")
        (destructuring-bind (_ identifier value) exp
          (wrap-export identifier
                       `(%var ,identifier
                              ,(transform-statements!
                                value env))
                       env)))
       (else:
        (map (rcurry transform-statements! env) exp))))
    ((<symbol>)
      exp)
    (else: exp)))